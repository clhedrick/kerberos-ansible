---

# I do flush handlers whenever I trigger a handler. I've had issues where
# the script fails. But when you rerun it a start or restart is missed because
  # the thing that triggered it is already there.

- hosts: testhosts dresden dresdesk faculty research staff services ilab studentvms grad apps coredev special researchuser wiselab stratosphere ahn1 aiart rll mscs rubik bekris appsold ccstar localhost foodaiGroup

  become: true
  environment:
    PATH: "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"
  tasks:
   - name: load config for distribution
     include_vars: "os-vars/{{ ansible_distribution }}.{{ansible_distribution_major_version}}.yml"

# the options are critical. the default will make the system unusable
# -K causes it to keep symlinks. without that if we sync /lib64, it turns it
#    from a symlink to a directory
# -O causes it not to change times on directories to the time here
   - name: common files
     synchronize: 
       src: "{{ playbook_dir }}/kerberos-files/copy/"
       dest: / 
       archive: no 
       perms: yes 
       recursive: yes
       times: yes
       rsync_opts:
         - "-KO"
         - "--exclude=*~"
     register: syncresult1

# os-specific files
   - name: os-specific files
     synchronize: 
       src: "{{ playbook_dir }}/kerberos-files/copy.{{ ansible_distribution }}.{{ansible_distribution_major_version}}/"
       dest: / 
       archive: no 
       perms: yes 
       recursive: yes
       times: yes
       rsync_opts:
         - "-KOl"
         - "--exclude=*~"
     register: syncresult2

# because rsync is done locally, it doesn't log the results on the target
# log them now
   - name: log results of rsync
     when: syncresult1.changed or syncresult2.changed
     command: logger -p user.info -t python
     args:
       stdin: "ansible-synchronize Changes done: {{ syncresult1.msg|default('') }}{{ syncresult2.msg|default('') }}"

# has to be done separately because of setuid bit
   - name: install kgetcred
     copy: src="{{ playbook_dir }}/kerberos-files/usr/bin/kgetcred" dest=/usr/bin/kgetcred owner=root mode=04755

# not sure what this is about. will be overwitten by next section even if it was needed
#   - name: temp hack for apps
#     when: cluster is defined and cluster == 'apps' and ansible_distribution_major_version == '7'
#     copy: src="{{ playbook_dir }}/kerberos-files/password-auth-ac-apps" dest=/etc/pam.d/password-auth-ac

   # limits. pam calls them, so the pam files have to be template driven
   # For the moment limits is supported for all OSs, but setlimits onlly for Centos 7
   # Setlimits could be implemented for SLES and the most recent Ubuntu, but not Ubuntu 14
   - name: pam files for centos 7
     when: use_pam_templates|default('false')|bool
     template: src="{{ playbook_dir }}/kerberos-files/etc/pam.d/{{ item }}" dest=/etc/pam.d/{{ item }} mode=0644 owner=root
     with_items: ['password-auth-ac', 'system-auth-ac']

# on Centos pam needs an selinux policy. selinux could be installed on Ubuntu, but I doubt
# the same policy would work
   - name: see if selinux is on
     when: ansible_distribution == 'CentOS'
     command: getenforce
     register: enforcing
     failed_when: false
     changed_when: false

   - name: install policy if selinux, dir
     when: enforcing.stdout is defined and 'Enforcing' in enforcing.stdout
     block: 
       - file: path=/usr/local/etc/selinux state=directory mode=755 owner=root
       - copy: src="{{ playbook_dir }}/kerberos-files/usr/local/etc/selinux/" dest=/usr/local/etc/selinux/ mode=600 owner=root
         notify:
          - load selinux

   - meta: flush_handlers

   - name: enable swap accounting if needed
     when: setlimits is defined and need_boot_swapaccount is defined and need_boot_swapaccount
     lineinfile: path=/etc/default/grub line='GRUB_CMDLINE_LINUX_DEFAULT="${GRUB_CMDLINE_LINUX_DEFAULT} swapaccount=1"'
     notify:
      - update grub

   - meta: flush_handlers

   - name: /usr/libexec/setlimits.sh if needed
     when: setlimits is defined
     template: src="{{ playbook_dir }}/kerberos-files/usr/libexec/{{ setlimits }}" dest=/usr/libexec/setlimits.sh owner=root mode=755

   - name: sessions command if setlimits set
     when: setlimits is defined
     copy: src="{{ playbook_dir }}/kerberos-files/usr/local/bin/sessions" dest=/usr/local/bin/sessions owner=root mode=755

   - name: remove /usr/libexec/setlimits.sh if not needed
     when: setlimits is not defined
     file: path=/usr/libexec/setlimits.sh state=absent

   - name: /etc/security/limits.d/40-lcsr.conf if needed
     when: limits is defined
     copy: src="{{ playbook_dir }}/kerberos-files/etc/security/limits.d/{{ limits }}" dest=/etc/security/limits.d/40-lcsr.conf owner=root mode=644

   - name: remove /etc/security/limits.d/40-lcsr.conf if not needed
     when: limits is not defined
     file: path=/etc/security/limits.d/40-lcsr.conf state=absent

   - name: /usr/libexec/killjob.sh if needed
     when: killjob is defined
     copy: src="{{ playbook_dir }}/kerberos-files/usr/libexec/{{ killjob }}" dest=/usr/libexec/killjob.sh owner=root mode=755

   - name: /etc/cron.d/killjob if needed
     when: killjob is defined
     copy: src="{{ playbook_dir }}/kerberos-files/etc/cron.d/killjob" dest=/etc/cron.d/killjob owner=root mode=644

   - name: remove /usr/libexec/killjob.sh  and /etc/cron.d/killjob if not needed
     when: killjob is not defined
     file: path={{ item }} state=absent
     with_items: ['/etc/cron.d/killjob', '/usr/libexec/killjob.sh']

# install pkinit if possible
   - name: install pkinit
     when: has_kinit_n is defined and has_kinit_n|bool
     package: name="{{ pkinit_package }}" state=present

# install chrony
   - name: install chrony
     when: chrony_broken is not defined
     package: name=chrony state=present

# skinit is slightly different depending upon whether kinit -n works
   - name: skinit
     template: src="{{ playbook_dir }}/kerberos-files/usr/local/bin/skinit" dest=/usr/local/bin/skinit mode=0755 owner=root

# renewd is separate because we have to restart it if it changes
   - name: renewd
     copy: src="{{ playbook_dir }}/kerberos-files/usr/sbin/renewd" dest=/usr/sbin/renewd owner=root mode=0755
     notify: 
     - restart renewd
   - meta: flush_handlers

# krb5.conf differs because ubuntu doesn't have /etc/krb5.conf.d and KEYRING doesn't work
# other conditionals have accumlated by now
   - name: krb5.conf
     when: not ( nokrb5conf is defined and nokrb5conf )
     template: src="{{ playbook_dir }}/kerberos-files/etc/krb5.conf" dest=/etc/krb5.conf owner=root mode=0644
   - name: remove kcm from /etc/krb5.conf.d/kcm_default_ccache
     # only do this when we've updated krb5.conf.
     # edir file rather than removing it so it doesn't get put back
     when: not ( nokrb5conf is defined and nokrb5conf )
     ini_file: path=/etc/krb5.conf.d/kcm_default_ccache create=no section=libdefaults option=default_ccache_name state=absent
     # ok if file no there
     failed_when: false

#   - name: clear /var/lib/gssproxy/clients/krb5cc_%U
#     shell: rm -f /var/lib/gssproxy/clients/krb5cc_*
#     args:
#       removes: "/var/lib/gssproxy/clients/krb5cc_*"

# sssd.conf differs per cluster and in other ways
   - name: /etc/sssd/sssd.conf
     template: src="{{ playbook_dir }}/kerberos-files/etc/sssd/sssd.conf" dest=/etc/sssd/sssd.conf mode=0600 owner=root
     notify: 
     - restart sssd

   - meta: flush_handlers

   - name: sssd timing fix for ubuntu 18
     when: need_sssd_timing_fix is defined and need_sssd_timing_fix
     block:
       - file: path="/etc/systemd/system/sssd.service.d" state=directory mode=0755 owner=root
       - copy: src="{{ playbook_dir }}/kerberos-files/etc/systemd/system/sssd.service.d/override.conf" dest=/etc/systemd/system/sssd.service.d/override.conf mode=0644 owner=root

   - name: sssd remove timing fix if not ubuntu 18, so we don't keep it for ubuntu gt 18
     when: not ( need_sssd_timing_fix is defined and need_sssd_timing_fix )
     file: path="/etc/systemd/system/sssd.service.d" state=absent

# for idfiles=true, sssd has to get id from /etc/passwd. So we need to add nslcd to decode groups
   - name: if idfiles, install nss_ldap packages
     when: idfiles is defined and idfiles
     package: name="{{ ldap_packages }}" state=present

   - name: if idfiles, configure nss_ldap
     when: idfiles is defined and idfiles
     template: src="{{ playbook_dir }}/kerberos-files{{ ldap_src|default('/etc/nslcd.conf') }}" dest="{{ ldap_dest|default('/etc/nslcd.conf') }}"
     notify:
     - restart nslcd     

# nsswitch.conf is slightly different for ubuntu
# this is not done for systems with authselect.
# authselect controls nsswitch, so if we need to change it on authselect systems
# change it that way. 
# Currently the default is OK for authselect, so we don't change it at all for those systems
   - name: nsswitch.conf
     when: not has_authselect|default('false')|bool
     template: src="{{ playbook_dir }}/kerberos-files/etc/nsswitch.conf" dest=/etc/nsswitch.conf owner=root mode=0644
     notify: 
     - maybe restart cron
   - meta: flush_handlers

# sshd_config is slightly different for ubuntu
   - name: /etc/ssh/sshd_config
     template: src="{{ playbook_dir }}/kerberos-files/etc/ssh/sshd_config" dest=/etc/ssh/sshd_config mode=0600 owner=root
     notify: 
     - restart sshd
   - meta: flush_handlers
# and ssh_config for centos 6, ssh_noknown2 set
   - name: /etc/ssh/sshd_config
     template: src="{{ playbook_dir }}/kerberos-files/etc/ssh/ssh_config" dest=/etc/ssh/ssh_config mode=0644 owner=root



# sssd does its own caching. If nscd is running we may have old data cached
#   that will make things not work for a while
# Done in kerberos-boot. I don't think we need it here
#   - name: kill nscd
#     service: name=nscd enabled=no state=stopped
#     ignore_errors: yes

# centos has no usable way to supplement their generated pam. So full pam
# files are included in copy.centos7. ubuntu lets you supply a file with modifications,
# so we can rebuild the pam files using their configurator. This is the file with our changes.
# it's separate because we have to call the configurator if it changes
   - name: rukerb pam config
     when: has_pam_configs|default('false')|bool
     template: src="{{ playbook_dir }}/kerberos-files/usr/share/pam-configs/rukerb" dest=/usr/share/pam-configs/rukerb
     notify:
     - rebuild pam
   - meta: flush_handlers

# new centos approach
   - name: fix authselect configurations
     when: has_authselect|default('false')|bool
     include_tasks: "{{ playbook_dir }}/kerberos-files/scripts/authselect.yml"
     loop:
     - /usr/share/authselect/default/sssd/password-auth
     - /usr/share/authselect/default/sssd/system-auth
# this script can notify "update authselect"
   - meta: flush_handlers


# I don't think we need this now. It was really a one-time fix
# fix protection for /run/renewdccs. original code in pam_reg_cc set it to 700, not 0700
# data services needs a special setup so zeppelin can write it
#   - name: fix protection for /run/renewdccs
#     when: ansible_fqdn != 'data-services2.cs.rutgers.edu'
#     file: path=/run/renewdccs mode=0700 state=directory owner=root

# note: I normally use the default ntp implement for a distro if it's OK
# I'm doing chrony on centos because it's now the default but our setups
# seem to use ntp. Chrony has better support if the system's clock drifts
# chrony.conf separate because we have to restart if changes
   - name: disable ntp if there
     when: chrony_broken is not defined
     service: name={{ ntp_name }} enabled=no state=stopped
     failed_when: false
   - name: disable ntpdate if there
     when: ntpdate_name != '' and chrony_broken is not defined
     service: name={{ ntpdate_name }}  enabled=no state=stopped
     failed_when: false
   - name: install chrony config
     when: chrony_broken is not defined
     copy: src="{{ playbook_dir }}/kerberos-files/etc/chrony.conf" dest="{{ chrony_config }}" owner=root mode=0644
     notify: 
     - restart chrony

# not sure what this is about. Not doing it in 7.5, and in a couple of cases we actually use it
# rename /etc/gssproxy/99-nfs-client.conf to /etc/gssproxy/99-nfs-client.conf.disabled
   - name: rename /etc/gssproxy/99-nfs-client.conf
     when: ansible_distribution == 'CentOS' and ansible_distribution_version == '7.4.1708'
     command: removes=/etc/gssproxy/99-nfs-client.conf mv /etc/gssproxy/99-nfs-client.conf /etc/gssproxy/99-nfs-client.conf.disabled
     notify:
     - restart gssproxy

# this fixes a bug in rpc.gssd. If the user has multiple credential caches, e.g. user and user-admin
# rpc.gssd returns the currently selected one. We actually want to return the one that matches the
# username. I created a ccselect plugin that selects the right principal. It's /usr/lib/ccselect_nfs.so.
# Normally I'd define it in the [plugins] section of /etc/krb5.conf. However it confuses sssd. Since
# only rpc.gssd really needs it, I create an addon systemd config file for rpc-gssd that defines
# KRB5_CONFIG to include both the normal krb5.conf and a file pointing to the plugin.
   - name: wrap rpc.gssd to make sure it gets the right principal
     when: gssd_use_plugin is defined
     block:
       - copy: src="{{ playbook_dir }}/kerberos-files/usr/lib/ccselect_nfs.so" dest=/usr/lib/ccselect_nfs.so mode=0755 owner=root
         notify:
            - daemon and gssd
       - file: path=/usr/libexec/gssd-wrap.so state=absent
       - file: path=/etc/systemd/system/rpc-gssd.service.d state=directory mode=0755 owner=root
       - file: path=/etc/systemd/system/rpc-gssd.service.d/gssd-wrap.conf state=absent
       - copy: src="{{ playbook_dir }}/kerberos-files/etc/krb5.conf.gssd" dest=/etc/krb5.conf.gssd mode=0644 owner=root
       - copy: src="{{ playbook_dir }}/kerberos-files/etc/systemd/system/rpc-gssd.service.d/gss-krb.conf" dest=/etc/systemd/system/rpc-gssd.service.d/gss-krb.conf mode=0644 owner=root
         notify:
            - daemon and gssd
     
   - name: ubuntu 18 patched rpc.gssd
     when: ansible_distribution == 'Ubuntu' and ansible_distribution_version == "18.04"
     copy: src="{{ playbook_dir }}/kerberos-files/usr/sbin/rpc.gssd.u18" dest=/usr/sbin/rpc.gssd mode=0755 owner=root
     notify:
        - daemon and gssd

#       - copy: src="{{ playbook_dir }}/kerberos-files/usr/libexec/gssd-wrap.so" dest=/usr/libexec/gssd-wrap.so mode=0755 owner=root
#         notify:
#           - daemon and gssd
#       - file: state=directory path=/etc/systemd/system/rpc-gssd.service.d/ mode=0755
#       - copy: src="{{ playbook_dir }}/kerberos-files/etc/systemd/system/rpc-gssd.service.d/gssd-wrap.conf" dest=/etc/systemd/system/rpc-gssd.service.d/gssd-wrap.conf mode=0644 owner=root
#        notify:
#           - daemon and gssd

   - meta: flush_handlers

   - name: lcsr sudoers
     template: src="{{ playbook_dir }}/kerberos-files/etc/sudoers.d/lcsr" dest=/etc/sudoers.d/lcsr mode=0600 owner=root

   - name: if autofs requested make sure it's installed
     when: (net_autofs is defined and net_autofs) or (nocommonmap is not defined or not nocommonmap)
     package: name="autofs" state=present

   - name: comment out /net in auto.master if present
     when: net_autofs is defined and net_autofs
     replace:
       path: /etc/auto.master
       regexp: '^(\s*)/net(.*)$'
       replace: '#\1/net\2'

   - name: autofs directory
     when: (net_autofs is defined and net_autofs) or (nocommonmap is not defined or not nocommonmap)
     file: path=/etc/auto.master.d mode=755 owner=root state=directory

   - name: autofs /net
     when: net_autofs is defined and net_autofs
     copy: src="{{ playbook_dir }}/kerberos-files/etc/auto.master.d/net.autofs" dest=/etc/auto.master.d/net.autofs mode=644 owner=root
     notify:
      - restart autofs

   - name: autofs /common
     when: nocommonmap is not defined or not nocommonmap
     template: src="{{ playbook_dir }}/kerberos-files/etc/auto.master.d/common.autofs" dest=/etc/auto.master.d/common.autofs mode=644 owner=root
     notify:
      - restart autofs

   - name: autofs /common/users
     when: nocommonmap is not defined or not nocommonmap
     template: src="{{ playbook_dir }}/kerberos-files/etc/auto.master.d/auto.common" dest=/etc/auto.master.d/auto.common mode=644 owner=root
     notify:
      - restart autofs

   - meta: flush_handlers

   - name: install /usr/libexec/clusterdatamkdir.sh
     when: clusterdata is defined 
     copy: src="{{ playbook_dir }}/kerberos-files/usr/libexec/clusterdatamkdir.sh" dest=/usr/libexec/clusterdatamkdir.sh mode=755 owner=root

   - name: create firefox config file for ubuntu
     block:
       - stat: path=/usr/lib/firefox/defaults/pref
         register: p
       - name: install firefox preference
         when: p.stat.exists
         copy: src="{{ playbook_dir }}/kerberos-files/usr/lib/firefox/defaults/pref/local-settings.js" dest=/usr/lib/firefox/defaults/pref/local-settings.js mode=0644 owner=root

  handlers:
    - name: restart renewd
      service: name=renewd state=restarted enabled=yes
    - name: restart sssd
      service: name=sssd state=restarted enabled=yes
    - name: rebuild pam
      command: pam-auth-update --package --force
    - name: restart sshd
      service: name={{ 'ssh' if ansible_distribution == 'Ubuntu' else 'sshd' }} state=restarted enabled=yes
    - name: restart chrony
      service: name={{ chrony_name }} enabled=yes state=restarted
    - name: restart gssproxy
      service: name=gssproxy state=restarted
    - name: restart autofs
      service: name=autofs state=restarted enabled=yes
    - name: load selinux
      command: semodule -i /usr/local/etc/selinux/kerbsemanage.pp
    - name: restart nslcd
      when: nslcd_service is defined
      service: name={{ nslcd_service }} state=restarted enabled=yes
    - name: daemon and gssd
      systemd: daemon_reload=yes name={{ gssd_service }} state=restarted
    - name: maybe restart cron
      when: need_sssd_cron_restart is defined 
      service: name={{ need_sssd_cron_restart }} state=restarted
    - name: update authselect
      command: authselect apply-changes
    - name: update grub
      command: update-grub
